import bc.*;
import java.util.List;
import java.util.ArrayList;

/**
 * Contains a "vector field" of directions of sorts; following arrows
 * will yield a path towards the target. Is not generated by instantiating
 * a new PathField, you must instead use PathMaster to generate one.
 */
public class PathField
{
    protected PlanetMap basemap;
    protected MapLocation target;
    protected PathPoint[][] field;

    public PathField(PlanetMap basemap, MapLocation target) {
        this.basemap = basemap;
        this.target = target;
        this.field = new PathPoint[(int)basemap.getWidth()][(int)basemap.getHeight()];
    }

    /*
     *   START PUBLIC-FACING METHODS THAT YOU SHOULD BE USING
     */


    /**
     * Checks if (x,y) is on the map, essentially (x,y positive, less than width,height)
     */
    public boolean isPointValid(int x, int y) {
        return (x>=0)&&(y>=0)&&(x<basemap.getWidth())&&(y<basemap.getHeight());
    }

    public boolean isPointValid(MapLocation ml) {
        return isPointValid(ml.getX(), ml.getY());
    }

    /**
     * Checks if this PathField has an entry for (x,y). You should try this before calling
     * getDirectionAtPoint and getDistanceAtPoint
     *
     * Cases where it does:
     *  - x,y is valid (on the map) AND is passable terrain AND is connected via passable
     *    terrain to the target location
     *
     * Cases where it doesn't
     *  - x,y is not valid (not on the map)
     *  - x,y does not contain passable terrain
     *  - x,y is not connected via passable terrain to target (more common on mars, where
     *     we tend to have disjointed "islands", because of reverse floodfilling)
     */
    public boolean isPointSet(int x, int y) {
        return field[x][y] != null;
    }

    public boolean isPointSet(MapLocation ml) {
        return isPointSet(ml.getX(), ml.getY());
    }

    /**
     * Returns the directions to move at this point to follow a shortest path to this
     * PathField's target
     */
    public Direction[] getDirectionsAtPoint(int x, int y) {
        return getPoint(x,y).dirs;
    }

    public Direction[] getDirectionsAtPoint(MapLocation ml) {
        return getDirectionsAtPoint(ml.getX(), ml.getY());
    }

    /**
     * Alias for getStraightestDirectionAtPoint so that old code is still backwards-compatible,
     * although the functionality is slightly different
     */
    public Direction getDirectionAtPoint(int x, int y) {
        return getStraightestDirectionAtPoint(x, y);
    }

    public Direction getDirectionAtPoint(MapLocation ml) {
        return getStraightestDirectionAtPoint(ml);
    }

    /**
     * Of the possible directions to move at this point that result in the shortest path, picks
     * the one that is the "straightest" path towards the target. This avoids behavior like
     * before, where units would take a shortest route, but because diagonal is not penalized,
     * it would be unnecessarily zig-zaggy.
     */

    public Direction getStraightestDirectionAtPoint(int x, int y) {
        Direction[] dirs = getDirectionsAtPoint(x,y);
        MapLocation cLoc = new MapLocation(target.getPlanet(), x, y);
        Direction optimalDir = cLoc.directionTo(target);
        Direction bestAvail = dirs[0];
        int bestAff = Utils.getDirectionAffinity(bestAvail, optimalDir);
        for(int i = 1; i < dirs.length; i ++) {
            if(dirs[i]==null) return bestAvail;
            if(Utils.getDirectionAffinity(dirs[i], optimalDir)>bestAff) {
                bestAff = Utils.getDirectionAffinity(dirs[i], optimalDir);
                bestAvail = dirs[i];
            }
        }
        return bestAvail;
    }

    public Direction getStraightestDirectionAtPoint(MapLocation ml) {
        return getStraightestDirectionAtPoint(ml.getX(), ml.getY());
    }

    /**
     * Assuming you follow the directions provided by this pathfield, the number of steps
     * you must take to reach this PathField's target
     */
    public int getDistanceAtPoint(int x, int y) {
        return getPoint(x,y).dist;
    }

    public int getDistanceAtPoint(MapLocation ml) {
        return getDistanceAtPoint(ml.getX(), ml.getY());
    }


    // uses internal class
    public PathPoint getPoint(int x, int y) {
        return field[x][y];
    }

    public PathPoint getPoint(MapLocation ml) {
        return getPoint(ml.getX(), ml.getY());
    }

    public MapLocation getTargetLocation() {
        return this.target;
    }


    /**
     * Gets the MapLocations that are N distance away from this PathField's target location.
     * That is, from any of these locations, the target of this PathField is N steps along
     * the path away. Note that this is NOT distance squared. This method also has an errorDist
     * built in, which says within what range 
     */
    public List<MapLocation> getPointsNAway(int n) {
        return getPointsNAway(n, 3);
    }
    
    //returns all the points n away from the target point
    public List<MapLocation> getPointsNAway(int n, int errorDist) {
        List<MapLocation> ret = new ArrayList<MapLocation>(75);
        for(int i = 0; i < field.length; i ++) {
            for(int j = 0; j < field[i].length; j ++) {
                if(!isPointSet(i,j)) continue;
                if(Math.abs(getDistanceAtPoint(i,j) - n) < errorDist) {
                    ret.add(new MapLocation(basemap.getPlanet(), i, j));
                }
            }
        }
        return ret;
    }
    
    public List<MapLocation> getPointsPercentAlong(MapLocation start, double perc, int errorDist) {
        int i = start.getX(), j = start.getY();
        int dist = field[i][j].dist;
        int n = (int)(perc * dist);
        return this.getPointsNAway(n,errorDist);
    }
    
    public List<MapLocation> getPointsPercentAlong(MapLocation start, double perc) {
        return this.getPointsPercentAlong(start, perc, 3);
    }

    /**
     *  END PUBLIC FACING METHODS
     */

    public void setPoint(int x, int y, Direction[] dirs, int dist) {
        field[x][y] = new PathPoint(dirs, dist);
    }

    public void setPoint(int x, int y, Direction dir, int dist) {
        Direction[] dirs = new Direction[8];
        dirs[0] = dir;
        field[x][y] = new PathPoint(dirs, dist);
    }

    public void addDirection(int x, int y, Direction dir) {
        field[x][y].addDirection(dir);
    }

    public class PathPoint
    {
        public final Direction[] dirs;
        public final int dist;
        public int numDirs;

        public PathPoint(Direction[] dirs, int dist) {
            this.dirs = dirs;
            this.dist = dist;
            this.numDirs = 0;
            for(Direction d : dirs)
                if(d!=null) this.numDirs += 1;
        }

        public void addDirection(Direction d) {
            this.dirs[this.numDirs++] = d;
        }

        public Direction[] getDirections() { return this.dirs; }
        public int getDistance() { return this.dist; }
    }
}